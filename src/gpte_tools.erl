-module(gpte_tools).

-export_type([
        tools/0
      , name/0
      , description/0
      , parameters/0
      , property_name/0
      , property/0
      , callback/0
      , function_option/0
    ]).

-export([
        new/0
      , add_functions/2
      , sample/1
    ]).

-type tools() :: #{
        functions => #{
            name() => #{
                description := description()
              , parameters := parameters()
              , callback := callback()
              % if args_type specified, callback Args will be an erlang term.
              % if args_type is not specified, Args will be raw json binstr.
              , args_type => gpte_schema:type()
            }
        }
    }.

-type name() :: atom().

-type description() :: unicode:unicode_binary().

-type parameters() :: #{
        type := object
      , properties := maps:map(property_name(), property())
      , required := [property_name()]
      , additionalProperties := boolean()
    }.

-type property_name() :: atom().

-type property() :: #{
        type => object | array | string | integer | number | boolean
      , description => unicode:unicode_binary()
      , properties => maps:map(property_name(), property())
      , required => [property_name()]
      , additionalProperties => boolean()
      , items => property()
      , enum => [atom()]
    }.

-type callback() :: fun((Args::any())->unicode:unicode_binary()).

-type function_option() :: #{
        json_reply => boolean() % default: false
      , catch_exception => boolean() % default: false
      , report_exception_detail => boolean() % default: false
      , report_exception_detail_to_ai => boolean() % default: false
    }.


-gpte_function_description({sample/1, <<"Sample erlang function.">>}).

-gpte_function_option({sample/1, #{
        json_reply => false
      , catch_exception => false
      , report_exception_detail => false
      , report_exception_detail_to_ai => false
    }}).

-spec sample(gpte_schema:sample()) -> unicode:unicode_binary().
sample(Args) ->
    iolist_to_binary(io_lib:format("~p~n", [Args])).


-spec new() -> tools().
new() ->
    #{}.

-spec add_functions(
        [{Module::atom(), FunctionName::atom(), Arity::non_neg_integer()}], tools()
    ) -> tools().
add_functions([], Tools) ->
    Tools;
add_functions([{Module, FunctionName, Arity}|Tail], Tools0) ->
    Name = case klsn_map:lookup([functions, FunctionName], Tools0) of
        {value, _} ->
            % atoms generated by this is at most the number of exported functions.
            binary_to_atom(iolist_to_binary([
                <<"gpte_tools___">>
              , atom_to_binary(Module)
              , <<"___">>
              , atom_to_binary(FunctionName)
              , <<"___">>
              , integer_to_binary(Arity)
            ]));
        none ->
            FunctionName
    end,
    FunctionSpec = build_function({Module, FunctionName, Arity}),
    Tools = klsn_map:upsert([functions, Name], FunctionSpec, Tools0),
    add_functions(Tail, Tools).

build_function({Module, FunName, Arity=1}) ->
    case code:which(Module) of
        non_existing ->
            error({gpte_tools_build_error, iolist_to_binary(io_lib:format(
                "module `~p` must exist"
              , [Module]
            ))});
        _ ->
            ok
    end,
    case
        lists:search(fun
            ({FunName0, Arity0}) when FunName0 =:= FunName, Arity0 =:= Arity ->
                true;
            (_)->
                false
        end, Module:module_info(exports))
    of
        {value, _} ->
            ok;
        false ->
            error({gpte_tools_build_error, iolist_to_binary(io_lib:format(
                "function `~p:~p/~p` must be exported"
              , [Module, FunName, Arity]
            ))})
    end,
    Specs = klsn_code:spec({Module, FunName, Arity}),
    [Spec | _] = Specs,
    {type, _, 'fun', [FunArgs, FunReturn]} = Spec,
    ArgsType = case FunArgs of
        {type,_,product,[{user_type,_,ArgTypeName,ArgArity}]} ->
            {Module, ArgTypeName, length(ArgArity)};
        {type,_,product,[{remote_type,_,RemoteType}]} ->
            [RemoteTypeModule, RemoteTypeName, RemoteTypeArity] = RemoteType,
            {atom, _, RemoteTypeModuleAtom} = RemoteTypeModule,
            {atom, _, RemoteTypeNameAtom} = RemoteTypeName,
            RemoteTypeArityLength = length(RemoteTypeArity),
            {
                RemoteTypeModuleAtom
              , RemoteTypeNameAtom
              , RemoteTypeArityLength
            };
        _ ->
            error({gpte_tools_build_error, iolist_to_binary(io_lib:format(
                "argument of `~p:~p/~p` must be a user_type or remote_type"
              , [Module, FunName, Arity]
            ))})
    end,
    case FunReturn of
        {remote_type,_,[{atom,_,unicode}, {atom,_,unicode_binary}, []]} ->
            ok;
        {remote_type,_,[{atom,_,klsn}, {atom,_,binstr}, []]} ->
            ok;
        {remote_type,_,[{atom,_,klsn_binstr}, {atom,_,binstr}, []]} ->
            ok;
        {remote_type,_,[{atom,_,jsone}, {atom,_,json_value}, []]} ->
            ok;
        _ ->
            error({gpte_tools_build_error, iolist_to_binary(io_lib:format(
                "`~p:~p/~p` must return unicode:unicode_binary() of jsone:json_value()"
              , [Module, FunName, Arity]
            ))})
    end,
    ArgsSchema = gpte_schema:schema(ArgsType),
    #{
        description => case {
                lookup_function_description({Module, FunName, Arity})
              , klsn_map:lookup([description], ArgsSchema)
            } of
                {{value, Desc}, _} ->
                    Desc;
                {none, {value, Desc}} ->
                    Desc;
                {none, none} ->
                    iolist_to_binary(io_lib:format(
                        "Erlang function `~p:~p/~p`"
                      , [Module, FunName, Arity]
                    ))
            end
      , parameters => maps:get(schema, ArgsSchema)
      , callback => build_callback_fun({Module, FunName, Arity})
      , args_type => ArgsType
    };
build_function({Module, FunName, Arity}) ->
    error({gpte_tools_build_error, iolist_to_binary(io_lib:format(
        "arity of `~p:~p/~p` must be exactly 1"
      , [Module, FunName, Arity]
    ))}).


-spec build_callback_fun({
        Module :: atom()
      , FunName :: atom()
      , Arity :: non_neg_integer()
    }) -> callback().
build_callback_fun({Module, FunName, _Arity=1}=Spec) ->
    Option = get_function_option(Spec),
    % This has to change if Arity is not limited to 1.
    fun(Args) ->
        try
            Res = Module:FunName(Args),
            case Option of
                #{json_reply := true} ->
                    iolist_to_binary(
                        jsone:encode(Res, [native_utf8, {indent, 2}, {space, 1}])
                    );
                _ ->
                    Res
            end
        catch
            Class:Error:Stack ->
                case Option of
                    #{report_exception_detail := true} ->
                        error_logger:error_report([
                            gpte_tools_callback_function_error
                          , {callback_function, Spec}
                          , {pid, self()}
                          , {class, Class}
                          , {error, Error}
                          , {stack, Stack}
                        ]);
                    _ ->
                        ok
                end,
                case Option of
                    #{catch_exception := true} ->
                        ok;
                    _ ->
                        erlang:raise(Class, Error, Stack)
                end,
                case Option of
                    #{report_exception_detail_to_ai := true} ->
                        IOL  = erl_error:format_exception(Class, Error, Stack),
                        Time  = erlang:system_time(microsecond),
                        Stamp = calendar:system_time_to_rfc3339(Time, [{unit,microsecond}]),
                        Report = io_lib:format(
                            "=ERROR REPORT==== ~s ===~n~ts",
                            [Stamp, IOL]),
                        iolist_to_binary(Report);
                    _ ->
                        <<"error">>
                end
        end
    end.



-spec lookup_function_description({
        Module :: atom()
      , FunName :: atom()
      , Arity :: non_neg_integer()
    }) -> klsn:maybe(klsn:binstr()).
lookup_function_description({Module, FunName, Arity}) ->
    Attributes = Module:module_info(attributes),
    Res = lists:filtermap(fun
        ({gpte_function_description, List})->
            Descriptions = lists:filtermap(fun
                ({{FunName0, Arity0}, Description}) when FunName0 =:= FunName, Arity0 =:= Arity ->
                    {true, Description};
                (_) ->
                    false
            end, List),
            case Descriptions of
                [] ->
                    false;
                _ ->
                    {true, Descriptions}
            end;
        (_) ->
            false
    end, Attributes),
    case Res of
        [[Value|_]|_] ->
            {value, Value};
        _ ->
            none
    end.

-spec get_function_option({
        Module :: atom()
      , FunName :: atom()
      , Arity :: non_neg_integer()
    }) -> function_option().
get_function_option({Module, FunName, Arity}) ->
    Attributes = Module:module_info(attributes),
    Res = lists:filtermap(fun
        ({gpte_function_option, List})->
            Descriptions = lists:filtermap(fun
                ({{FunName0, Arity0}, Description}) when FunName0 =:= FunName, Arity0 =:= Arity ->
                    {true, Description};
                (_) ->
                    false
            end, List),
            case Descriptions of
                [] ->
                    false;
                _ ->
                    {true, Descriptions}
            end;
        (_) ->
            false
    end, Attributes),
    DefaultOption = #{
        json_reply => false
      , catch_exception => false
      , report_exception_detail => false
      , report_exception_detail_to_ai => false
    },
    lists:foldl(fun(Elem, Ack)->
        maps:merge(Ack, Elem)
    end, DefaultOption, lists:flatten(Res)).

