-module(gpte_tools).

-export_type([
        tools/0
      , name/0
      , description/0
      , parameters/0
      , property_name/0
      , property/0
    ]).

-export([
        new/0
      , add_functions/2
      , sample/1
    ]).

-type tools() :: #{
        functions => #{
            name() => #{
                description := description()
              , parameters := parameters()
              , callback := fun((Args::any())->unicode:unicode_binary())
              % if args_type specified, callback Args will be an erlang term.
              % if args_type is not specified, Args will be raw json binstr.
              , args_type => gpte_schema:type()
            }
        }
    }.

-type name() :: atom().

-type description() :: unicode:unicode_binary().

-type parameters() :: #{
        type := object
      , properties := maps:map(property_name(), property())
      , required := [property_name()]
      , additionalProperties := boolean()
    }.

-type property_name() :: atom().

-type property() :: #{
        type => object | array | string | integer | number | boolean
      , description => unicode:unicode_binary()
      , properties => maps:map(property_name(), property())
      , required => [property_name()]
      , additionalProperties => boolean()
      , items => property()
      , enum => [atom()]
    }.

-gpte_function_description({sample/1, <<"Sample erlang function.">>}).
-spec sample(gpte_schema:sample()) -> unicode:unicode_binary().
sample(Args) ->
    iolist_to_binary(io_lib:format("~p~n", [Args])).


-spec new() -> tools().
new() ->
    #{}.

-spec add_functions(
        [{Module::atom(), FunctionName::atom(), Arity::non_neg_integer()}], tools()
    ) -> tools().
add_functions([], Tools) ->
    Tools;
add_functions([{Module, FunctionName, Arity}|Tail], Tools0) ->
    Name = case klsn_map:lookup([functions, FunctionName], Tools0) of
        {value, _} ->
            % atoms generated by this is at most the number of exported functions.
            binary_to_atom(iolist_to_binary([
                <<"gpte_tools___">>
              , atom_to_binary(Module)
              , <<"___">>
              , atom_to_binary(FunctionName)
              , <<"___">>
              , integer_to_binary(Arity)
            ]));
        none ->
            FunctionName
    end,
    FunctionSpec = build_function({Module, FunctionName, Arity}),
    Tools = klsn_map:upsert([functions, Name], FunctionSpec, Tools0),
    add_functions(Tail, Tools).

build_function({Module, FunName, Arity=1}) ->
    case code:which(Module) of
        non_existing ->
            error({gpte_tools_build_error, iolist_to_binary(io_lib:format(
                "module `~p` must exist"
              , [Module]
            ))});
        _ ->
            ok
    end,
    case
        lists:search(fun
            ({FunName0, Arity0}) when FunName0 =:= FunName, Arity0 =:= Arity ->
                true;
            (_)->
                false
        end, Module:module_info(exports))
    of
        {value, _} ->
            ok;
        false ->
            error({gpte_tools_build_error, iolist_to_binary(io_lib:format(
                "function `~p:~p/~p` must be exported"
              , [Module, FunName, Arity]
            ))})
    end,
    {ok, Concrete} = dialyzer_utils:get_core_from_beam(code:which(Module)),
    {ok, Map, _} = dialyzer_utils:get_spec_info(Module, Concrete, dict:new()),
    FullSpec = case klsn_map:lookup([{Module, FunName, Arity}], Map) of
        {value, FullSpec0} ->
            FullSpec0;
        none ->
            error({gpte_tools_build_error, iolist_to_binary(io_lib:format(
                "function `~p:~p/~p` must have a spec"
              , [Module, FunName, Arity]
            ))})
    end,
    Spec = element(1, hd(element(3, element(2, FullSpec)))),
    {type, _, 'fun', [FunArgs, FunReturn]} = Spec,
    ArgsType = case FunArgs of
        {type,_,product,[{user_type,_,ArgTypeName,ArgArity}]} ->
            {Module, ArgTypeName, length(ArgArity)};
        {type,_,product,[{remote_type,_,RemoteType}]} ->
            [RemoteTypeModule, RemoteTypeName, RemoteTypeArity] = RemoteType,
            {atom, _, RemoteTypeModuleAtom} = RemoteTypeModule,
            {atom, _, RemoteTypeNameAtom} = RemoteTypeName,
            RemoteTypeArityLength = length(RemoteTypeArity),
            {
                RemoteTypeModuleAtom
              , RemoteTypeNameAtom
              , RemoteTypeArityLength
            };
        _ ->
            error({gpte_tools_build_error, iolist_to_binary(io_lib:format(
                "argument of `~p:~p/~p` must be a user_type or remote_type"
              , [Module, FunName, Arity]
            ))})
    end,
    case FunReturn of
        {remote_type,_,[{atom,_,unicode}, {atom,_,unicode_binary}, []]} ->
            ok;
        {remote_type,_,[{atom,_,klsn}, {atom,_,binstr}, []]} ->
            ok;
        {remote_type,_,[{atom,_,klsn_binstr}, {atom,_,binstr}, []]} ->
            ok;
        _ ->
            error({gpte_tools_build_error, iolist_to_binary(io_lib:format(
                "`~p:~p/~p` must return unicode:unicode_binary()"
              , [Module, FunName, Arity]
            ))})
    end,
    ArgsSchema = gpte_schema:schema(ArgsType),
    #{
        description => case {
                lookup_function_description({Module, FunName, Arity})
              , klsn_map:lookup([description], ArgsSchema)
            } of
                {{value, Desc}, _} ->
                    Desc;
                {none, {value, Desc}} ->
                    Desc;
                {none, none} ->
                    iolist_to_binary(io_lib:format(
                        "Erlang function `~p:~p/~p`"
                      , [Module, FunName, Arity]
                    ))
            end
      , parameters => maps:get(schema, ArgsSchema)
      , callback => erlang:make_fun(Module, FunName, Arity)
      , args_type => ArgsType
    };
build_function({Module, FunName, Arity}) ->
    error({gpte_tools_build_error, iolist_to_binary(io_lib:format(
        "arity of `~p:~p/~p` must be exactly 1"
      , [Module, FunName, Arity]
    ))}).


-spec lookup_function_description({
        Module :: atom()
      , Type :: atom()
      , Arity :: non_neg_integer()
    }) -> klsn:maybe(klsn:binstr()).
lookup_function_description({Module, Type, Arity}) ->
    Attributes = Module:module_info(attributes),
    Res = lists:filtermap(fun
        ({gpte_function_description, List})->
            Descriptions = lists:filtermap(fun
                ({{Type0, Arity0}, Description}) when Type0 =:= Type, Arity0 =:= Arity ->
                    {true, Description};
                (_) ->
                    false
            end, List),
            case Descriptions of
                [] ->
                    false;
                _ ->
                    {true, Descriptions}
            end;
        (_) ->
            false
    end, Attributes),
    case Res of
        [[Value|_]|_] ->
            {value, Value};
        _ ->
            none
    end.

